## 初探JVM虚拟机

### 1、 JVM探究

面试问题 ：

* 谈谈对JVM的理解？ java8虚拟机和之前的变化更新？
* 什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？
* JVM的常用调优参数有哪些？
* 内存快照如何抓取，怎么分析Dump文件？知道吗？
* 谈谈JVM中，类加载器你的认识？

三种JVM

Sun HotSpot、BEA  JRockit、IBM J9 VM

![img](http://www.javainterviewpoint.com/wp-content/uploads/2016/01/JVM-Architecture.png)

### 2、JVM的位置

![image-20220317181135142](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220317181135142.png)

### 3、JVM的体系结构

![image-20220318131856103](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220318131856103.png)

### 4、类加载器

![image-20220320152550030](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220320152550030.png)

* 作用：
  * 加载Class文件，Class文件本身是存在与硬盘上的物理文件，将他存入内存中，并最终放入方法区成为一个元数据模板，这个过程就需要类加载器来进行
  * 类加载器只进行加载，是否可以运行，要由执行引擎来决定
  
* 过程

  1. **加载**：通过类的全限定名获取定义此类的二进制字节流；将这个字节流代表的静态存储结构放入方法区运行时数据结构；在内存中生产一个Class对象，作为方法区这个类的各种数据访问入口
  2. **链接**
     1. *验证*：确保Class文件的字节流中包含的信息符合虚拟机规范
     2. *准备*：为类变量分配内存并设置类变量的默认初始值，不包括final修饰的static
     3. *解析*：一般在初始化之后执行，将符号引用转换为直接引用
  3. **初始化**：收集静态代码和静态代码块进行合并(clinit方法)

* 类型

  三类加载器是包含关系

  1. 启动类（根）加载器（Bootstrap ClassLoader）
     * 是使用c/c++编写，嵌套在jvm中，只负责加载Java的核心类库(例如rt.jar)
     * 并不继承ClassLoader类，加载扩展类和应用程序加载器，并指定为他们的父加载器
     * 只加载Java，Javax，sun等开头的类
  2. 扩展程序加载器（Extension ClassLoader）
     * Java语言编写，派生于ClassLoader类；jre/lib/ext子目录
  3. 应用类加载器（AppClassLoader）
     * Java语言编写，派生于ClassLoader类；加载classpath下的类库

### 5、双亲委派机制

* 避免类的重复加载；防止核心类被随意篡改

![image-20220320152931945](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220320152931945.png)

* Java中类的加载是按需来进行加载的，当需要这个类时才会将其加载进内存生产class对象
* 当一个类收到了类加载的请求时，并不会直接加载，而是向上委托其父类进行加载，若父类还有父类，则一致向上委托直到到达引导类加载器
* 当引导类加载器有该类时，会对其进行加载（也就是为什么我们写一个和String同包同名的类，调用的还是原始String类），若父类没有则会跑异常，并交给子类进行处理，若一直没有可以处理的子类就会报出Class Not Found的错误

### 6、沙箱安全机制（了解）

* 就是将Java代码限定在JVM特定的运行范围内，保护核心类不会收到破坏的机制

### 7、Native

* Java的关键字，带了这个关键字就代表着Java已经调用不到了，要去调用C语言的库，会进入本地方法栈
* JNI就是Java Native Interface 主要作用时扩展Java的使用，融合其他技术
* 在内存中有一个特殊的区域登记native方法，Native Method Stack；最终执行时通过JNI加载本地方法库中的方法

### 8、PC寄存器

Program Counter Register（程序计数寄存器）

* 作用：每个线程都有一个pc寄存器，是线程私有的；可以理解为一个指针pc寄存器用来存储指向下一条指令的地址，由执行引擎读取下一条指令；是一个非常小的内存空间，小到可以忽略
* 是JVM中唯一一个不会出现OOM的区域

**为什么要使用PC寄存器/使用它的作用**

* 因为cpu会不停的切换各个线程，所以需要pc寄存器来记录当前执行到了哪一行，方便后续操作

**为什么PC寄存器是线程私有的**

* 为了能够正确的记录各个线程正在执行的当前字节码指令地址，如果共用一个会发送混乱

### 9、方法区

#### 理论

![image-20220324104605140](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220324104605140.png)

* ==静态变量，常量，类信息(构造方法，接口定义)、运行时的常量池存在方法区中，实例变量存在堆内存，与方法区无关==
  * static、final、Class、常量池
  * 1.7的时候经历了去永久代将静态变量和字符串常量池放入了堆中，1.8之后也还在堆中
    * 因为开发中会有大量的字符串被创建，回收效率低(FGC才会触发)，导致永久代内存不足，在堆中更容易回收
  * 也就是说1.8开始没有了永久代，方法区的具体实现变成了元空间，元空间在存放了类型信息，字段，方法，常量；而静态变量和字符串常量池还在堆中
  * **总结**：在new对象之后不管是类变量还是静态变量或者局部变量，他们的对象都是存在堆中的也就是**对象的实例都是在堆中存放的**；而我们说的静态变量去了堆中是指的，他的引用存放在了堆中，也就是说(static Car car = new Car())中的car在jdk1.7之后放入了堆中，而不是方法区了；1.7之后*car*若是类变量放在堆，静态变量也是堆，局部变量在栈
* 1.8之后使用  `-XX:MetaspaceSize`(设置初始的元空间大小默认21M，如果超了会触发FGC，之后会根据释放了多少元空间重新定义这个初始值) 和 `-XX:MaxMetaspaceSize`(默认是-1没有限制，超过本地内存也会OOM)设置元空间大小
* 元空间是方法区的一中实现手段，在1.8之前是使用永久代，但永久代容易发生OOM(加载了过多的类比如加载很多第三方jar包)所以将其替换为元空间，元空间是根据本地内存来的，所以理论上的最大值是本地内存最大值
* **为什么要替换永久代**：1.为永久代设置空间大小是很难确定的。2.为永久代调优比较困难

#### 内存结构

![img](https://img-blog.csdnimg.cn/img_convert/3dc10ad79b9d3716198cd0e5b32c63d8.png)

##### 常量池

* 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。
* 常量池就好比是一个表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。
  * 常量池也可以理解为原材料，我们写的方法就是一道道的菜，每次都去原材料区拿对应的原材料做出各种各样的菜

##### 运行时常量池

* 常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，**这部分内容将在类加载后存放到方法区的运行时常量池中**
* 在加载类或接口的时候就会创建对应的运行时常量池；而此时运行时常量池中的就不再是Class文件中常量池的符号引用了，而是替换成了直接引用

#### 方法区的垃圾回收

* 方法区的垃圾收集主要回收两部分内容：**常量池中废弃的常量和不再使用的类型**（类型费力不讨好，要求苛刻）
* Java虚拟机规范中并没有明确指出要在方法区进行垃圾回收

### 10、栈

#### 虚拟机栈

![image-20220322180930457](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220322180930457.png)

* 栈是运行时单位，堆是存储单位；栈解决程序的运行问题，而堆则是解决数据的存储问题
* 在线程创建的时候就会创建一个栈，栈是属于线程私有的，生命周期与线程一样；
* 栈中存放了一个个的栈帧，栈中数据都是以栈帧的格式存在，每一个栈帧就对应了一个方法调用；在栈顶的方法就是当前方法；先进后出
* 对于栈来说不存在垃圾回收GC；当栈的内存大小是固定的（-Xss 1m  *设置大小*），如果满了会报错StackOverflowError，栈溢出；当栈的内存大小是动态的，栈满了之后区申请内存，结果没有获取到预期的内存会报OOM
* FILO先进后出

#### 栈帧

* ==局部变量表==

  * 决定了栈帧的大小，栈帧的大小决定了栈可以存放多少个栈帧，栈帧的多少决定可以调用 多少方法

  * 定义为一个数字数组，最基本存储单元叫槽(Slot)，主要用于存储方法参数和定义在方法内的局部变量；不存在线程安全；编译时即确定大小
    * slot中32位的占一个槽，64(long,double)占两个槽；调用的时候占两个槽的调用它的第一个索引
    * 实例方法和构造方法在index0的位置放了this这个局部变量，静态方法不可以调用this
  * 局部变量表中的变量只在当前方法有效，当方法调用结束，随着栈帧的结束，局部变量表也随之消失
  * 局部变量表的变量是垃圾回收的根节点，只要被局部变量表直接间接引用的对象就不会被回收

* ==操作数栈==

  * 主要用于保存计算过程中的中间值，同时作为计算过程中变量临时的存储空间
  * 栈帧创建，操作数栈就创建了，此时的操作数栈还是空的
  * JVM的解释引擎是基于栈的执行引擎，其中的栈就是指的操作数栈
  * 由于栈中出栈入栈频率高，导致相较于寄存器效率较低，因此有了一个栈顶缓存技术，即将栈顶的数据全部缓存到物理的CPU寄存器中来操作，以提高效率

---

当方法执行的时候，先将15压入操作数据栈，之后执行下一行指令，将15放入局部变量表的1位置(0位置是this)，依次将8放入操作数栈，之后将8和15取出有执行引擎将器相加再放回局部变量表3索引处，最后寄存器执行return方法结束；所以局部变量表的大小是4而操作数栈只需要2

![image-20220322122650483](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220322122650483.png)

---

* 动态链接
  * 栈帧中指向方法区的运行时常量池
  * 在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为**符号引用**，保存在 Class 文件的常量池中(之后会去方法区的运行时常量池)。比如：我们定义一个方法A一个方法B，在B中调用了方法A，那么字节码文件中B方法就会有一个指向A方法的引用，在执行的时候就知道是去执行方法A了；那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

* 方法返回地址
  * 存放调用该方法的pc寄存器的值；即有两个方法A,B再A中调用了B，在B正常结束后，会将下一条指令存到方法返回地址，再给到pc寄存器，执行引擎读取寄存器后就知道要继续执行A方法的某一行了；若是发生异常就不会返回任何值，而是按照异常抛出给调用者
* 一些附加信息
  * 可选，并不是都有，就是栈帧还允许附带一些Java虚拟机实现相关的附加信息
  * 动态链接，方法返回地址，一些附件信息也被称为帧数据区

#### 本地方法栈

* 本地方法栈是管理本地方法的调用，上面说的栈可以叫虚拟机栈是管理Java方法的调用

#### Java对象在内存中实例化的过程图

### 11、堆

#### 理论



![image-20220323170728003](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220323170728003.png)

* Java 堆是 Java 虚拟机管理的内存中最大的一块(*在JVM启动的时候就确定了*)，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎(*逃逸分析*)所有的对象实例以及数据都在这里分配内存。
* 在方法结束后，堆内的对象不会马上移除，而是要等待GC；堆是GC的重点清理对象

* 为了进行高效的垃圾回收，虚拟机把堆内存**逻辑上**划分成三块区域（分代的唯一理由就是优化 GC 性能）：

  * jdk1.8及以后将原来的永久代替换成了元空间

  * 新生区（新生代，年轻代）：新对象和没达到一定年龄的对象都在新生代
  * 养老区（老年代，老年区）：被长时间使用的对象(比如连接型的对象)，老年代的内存空间应该要比年轻代更大
  * 元空间（永久区，永久代<jdk8之前>）

#### 设置堆空间大小

* 初始值-Xms (新生代+老年代)；-Xmx最大值（-Xms600m -Xmx600m）
* 默认情况下初始值是电脑内存的64分之一，最大是4分之一

#### 新生代和老年代

* 为什么要有新生代和老年代：因为不同的对象存货周期不同，有的时间很长有的很短，区分开有利于不同的垃圾回收，提高效率
* 为什么有幸存者区：因为如果每次新生代清理的时候就把对象存到老年区会很快把老年区撑爆触发FGC，FGC的代价是很高的，而放入幸存者区会降低老年区的压力，若达到阈值还在，那就放入老年区；0区和1区是为了解决垃圾回收产生的碎片化

对象在堆中的分配

<img src="C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220323232139908.png" alt="image-20220323232139908" style="zoom: 80%;" />

##### 新生代

* 新生代老年代内存占比默认是1：2；`-XX:NewRatio=2`；可以调节占比

* 默认情况年轻代的伊甸园和幸存者区占比8：1：1；`-XX:SurvivorRatio` 来配置

* 若在 JDK 7 中开启了 `-XX:+UseAdaptiveSizePolicy`，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄

  此时 `–XX:NewRatio` 和 `-XX:SurvivorRatio`  将会失效，而 JDK 8 是默认开启`-XX:+UseAdaptiveSizePolicy`

  在 JDK 8中，**不要随意关闭**`-XX:+UseAdaptiveSizePolicy`，除非对堆内存的划分有明确的规划

#### TLAB

* 从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内

* 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为**快速分配策略**

* OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计
* 一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存

#### 逃逸分析

* 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸；就可以将他放在栈上了，也就不存在GC了。
* 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。
* 也就是说开发中能使用局部变量就不要定义在方法外

##### 优化

* **栈上分配**：将堆分配转化为栈分配。JIT在编译期间通过逃逸分析如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配
* **同步省略**：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步，将锁消除；例如在方法体内new了对象又给该对象加了锁，那么这个锁是没有意义的，编译之后的字节码文件还有这个锁，但在执行时会把这个锁去掉
* **分离对象或标量替换**：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存(堆)，而存储在 CPU 寄存器(栈)
  * 标量：无法再分解成更小的数据的数据，例如基本数据类型；
  * 也就是说我们可以将一个聚合量(比如一个bean里面定义了两个属性，一个是基本类型，另一个是引用)，拆分成两个标量存入栈中(栈帧的局部变量表)；当引用也可以拆成一个标量的话就存入栈，不能的话就是将那个基本类型存进去
* 那么这个时候就涉及到一个问题了，是不是**所有的对象都是分配在堆中？**--->否，因为我们可以通过逃逸分析，实现栈上分配；但是呢由于这个逃逸分析并不是很成熟，比如经过了逃逸分析，结果发现没有一个对象是不逃逸的，那么就浪费了一次逃逸分析，而逃逸分析本身也是一件消耗性能的事情；所以说并没有去使用它，但是能打开逃逸分析又确实变得很快，这只能说明做了标量替换的工作；而标量替换是将对象中的一部分或全部打散放入栈中，严格意义上他也不是对象了

---

OOM：堆中创建过多的对象会撑爆堆空间，也就是当老年代满了的时候，就会报OOM；方法区不停的创建过多的类也会撑爆，也会报OOM

StackOverflowError：栈中有过多的方法被调用，例如A调用B，B调用A就会占满栈，栈就会溢出；若栈的大小是动态的，那么在尝试扩展的时候没有得到足够的内存，也会报OOM（栈没有GC）

---

### 12、执行引擎

执行引擎主要包括了：解释器；JIT编译器；GC垃圾回收器

![image-20220324224121825](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220324224121825.png)

* JVM 的主要任务是负责装载字节码到内存，但字节码并不能够直接运行在操作系统之上，因为字节码指令不是机器指令，它内部包含的仅仅只 是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。
* 那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine） 的任务就是将字节码指令**解释/编译**为对应平台上的本地机器指令才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。
* **解释器**：当 Java 虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。现在都是用的模板解释器将一条字节码与一个模板函数关联，模板函数有这个字节码对应的机器码，提升性能
* **JIT（Just In Time Compiler）编译器**：就是虚拟机将源代码一次性直接编译 成和本地机器平台相关的机器语言，但并不是马上执行
* *逐行解释执行效率低,JVM会针对使用频率较高的热点代码进行编译并缓存起来,执行效率提高*
  * 热点代码探测来确定是否要开启JIT，也就是当一个方法被多次调用(方法调用计数器)，或者以一个方法体内循环次数(回边计数器)较多的循环体都可以称为热点代码，通过方法调用计数器来统计方法的调用次数，在server模式下调用超过10000就会jit
  * 热度衰减：当超过一定的时间限度，而方法的调用次数仍不足以让它提交给即时编译器，那这个方法的调用计数器就会被减少一半，这个过程就是衰减(要不然只要执行的时间够长，都会被JIT)
* 为什么有了JIT还要解释器：编译是需要时间的，*使用JVM刚刚启动后,可以先通过解释器 解释执行代码.之后再使用编译器编译执行,两者结合在一起*

### 13、对象的内存布局

![image-20220327211817180](C:\Users\洋\AppData\Roaming\Typora\typora-user-images\image-20220327211817180.png)

* 对象头包含运行时元数据：比如堆中的地址值，分代年龄，锁标志等等；类型指针：在元空间有一个保存类型的地方，比如我们可以通过getClass()获取它由谁创建若是对象是数组还会记录长度
* 实例数据：一些类信息