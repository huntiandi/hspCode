## 高频面试题

### Java基础

* **jdk和jre区别**：jdk包含了jre，jre只是运行时的工具而jdk是完整的运行开发工具包

* **字节码文件**：Java是跨平台的，而这一特性是由于jvm可以运行字节码文件，也就是说jvm针对不同平台进行了不同的实现，所以Java的字节码文件可以在任意平台的jvm上运行

* **基本类型**：byte(8)，short，int，long，float，double(64)，Boolean，char(16Unicode)；
  * 默认转换：byte,short,char --» int --» long --» float --» double；所以substring中可以传入char类型的参数
  * 如果强制将高专为低会导致精度丢失
  
* **值传递**：Java采用的是值传递而非应用传递，地址值也是值；值传递意味着传递的参数是原来参数的一个副本，所以对其进行修改原参数是不受影响的，而Java中对象的传递之所以会改变是因为传递的时候传递了对象地址值，因此会改变，如果在接受参数后(User user) user = new User();那么此时对user进行修改，原来的user就不会受影响了；因此Java中只有值传递没有引用传递

* **自动装箱和拆箱**：装箱使用valueof方法，拆箱使用(int,long...)Value方法；在Integer中缓存了-128~127，所以当Integer在次范围内为true除非使用的是new Integer()创建，在此范围外就是false了；需要注意的是Double可就没这个缓存了，因为范围内整数时固定的浮点数有无数

* **+=**：a = a+b和a +=b的区别：+=会进行隐式的类型转换也就是说会把右边的类型强制转换为左边的类型，例如short s = s +1;会报错，因为short类型在运算时会自动转为int类型，而左边时short类型所以会报错，应该改为short s+=1;

* **序列化**：传统的序列化有实现Serializable接口，现在还有json序列化以及fastJson序列化等；其中可以使用Gson.toJson转为json格式也可以使用Gson.fromJson来反序列化

* **内部类**：局部内部类(访问外部所有成员属性,方法)，成员内部类，静态内部类(成员内部类加上static就是静态内部类)，匿名内部类

* **三大特性**：封装继承多态，封装是指把对象的属性和行为封装到一个类种，属性是变量，行为是方法；继承是指子类拥有父类的属性(非private)和方法，以及可以对父类进行扩展；多态是指程序定义中左右两边的类型不一致也就是编译看左边运行时看右边(因此调用方法时会调用子类重写的方法)，多态的前提是继承所以必须发生在父子类中

* **重写重载**：重写发生在子父类中，方法名参数名返回值类型都要一致；重载发生在同一类中，方法名一致，参数类型不一致，返回值类型不影响

* **反射**：jdbc就是典型的反射Class.forName("驱动")；其中获取反射的方式有几种：通过forName，类名.class，对象名.getClass包装类型可以使用TYPE属性；反射效率低

* **String**：string时不可变的因为被final修饰了char数组，buffer是线程安全的因为加了synchronization锁，build是不安全的但是效率高，buffer和build都是可变的使用append方法
  
  * 常见方法：charAt，length，indexOf，replace，trim，subString，split，equals
  
* **接口&抽象类**：接口没有构造器抽象类有；接口能实现多个抽象类只能一个；抽象类可以定义成员变量接口都是常量；抽象类可以是任意类型，接口都是public；抽象类里面可以有非抽象方法接口不行除非default；抽象类可以有静态方法接口1.8后也可以的那必须有方法体；都不能被实例化

* **类加载**：加载，链接，初始化；将类加载到jvm中使用双亲委派机制，链接分为：验证，准备，解析(验证语法等，准备默认值，地址，将符号引用变为直接引用)；初始化是收集静态代码进行合并
  
  * Java源文件-class字节码文件-加载-连接(验证-准备-解析)-初始化
    * 加载：查找和导入class文件
    * 验证：检查文件的准确性
    * 准备：为文件分配内存
    * 解析：将符号引用转为直接引用
    * 初始化：执行静态资源
  
  * **如何打破双亲委派机制**：自定义classloader，并重写loaderClass方法；例如tomcat中，给每一个web项目都设置了webAppClassLoader这样就保证了多个web应用之间路径一样实现不一样的类的冲突
  * 也就是在tomcat中boot➡EXt➡APP➡web与tomcat共享类加载器➡tomcat自身加载器/web共享加载器➡web私有加载器
  * 还有一种是线程上下文加载器：这种一般例如JDBC中用的较多，本身DriverManager是应该由Boot加载器去加载，但是在具体获取Connection(连接)的时候是需要使用App加载器的那这时本身应该由Boot加载的变成了线程上下文加载，可以说是也可以说不是把

###### 克隆的使用场景

* 当我们定义了一个User user = new User();User user2 = user;在我们将user赋值给user2之后，我们通过user2取修改user种的属性，之后将user和user2输出，会发现，两个的值全部都是user2修改之后的值，此时我们想要user和user2显示不同的值，于是就需要使用到克隆
* 克隆的前提式user对象实现Cloneable接口，重写clone方法；之后在赋值时User user2 = (user)user.clone();就可以了；String做为引用类型也可以改变是因为，他是一个不可变类型，所以其实是创建了一个新的string类型
* 但上面的克隆也叫浅克隆，因为这样只能让对象的基本类型改变，而不能让user中的引用类型得到改变，因此，我们需要深克隆，深克隆有两种方式一种是让所有的引用类型都实现cloneable接口，一种时序列化即将对象序列化到流中，再从流中反序列化出来

###### 为什么boolean类型不能使用is开头

* 因为boolean类型的值在生成get/set方法时，get方法默认时isxxx()，而set方法默认是会把is去掉的，因此如果在rpc调用或者反序列化的时候，就会导致系统找isXXX以为是xxx而此时找不到xxx而报错

##### 接口的调用

###### 第三方接口调用

1. new一个url类放入要请求的url地址
2. url的openConnection方法，使用HttpURLConnection接收
3. 对其进行参数设置，例如请求方式，编码格式，超时时间等
4. 之后调用UrlConnection的输出流，进行write，flush等操作，这就是向第三方发送请求
5. 可以使用coon判断是否200成功；最后调用coon的getInputStream方法，readLine读取得到返回值

###### 接口的幂等性；表单重复提交，接收表单提交内容，

* 接口的幂等性就是表单的重复提交，典型的支付失败的列子；
  1. 在编写代码时不要使用转发，使用重定向
  2. 在代码层面，有两种解决方法，一是逻辑控制，例如给用户的订单添加状态信息，在update时where条件中添加状态信息，以保证，只有未支付状态下才会update；
  3. 二添加token，在请求时添加token参数，token在访问前台页面时由后端生成，在前台访问时，将其进行比较，若比对成功，执行语句，并在提交后删除就token生成一个新的随机token返回给其那台，若前台再次访问则时老token已经无法匹配成功了

### Java集合

* list：有序，不可重复；set：无序不可重复；map：key-value形式

#### HashMap

##### 概念

* 默认大小是16扩容的时候是12因为要成0.75，大小必须是2的幂次（因为一方面如果是奇数的话最后计算时低位永远是0那么会有一半的空间浪费，而如果是偶数则不会；还有就是在扩容的时候，扩容后的角标要么还是原来的角标要么就是原来的角标加扩容数
* hashmap是不安全的，hashtable是安全的；table不允许null为key，table好像已经废了，安全可以使用CocurrentHashMap
* 三个集合视图：keySet，values，entrySet
* TreeMap要求传入的类必须实现Comparable

##### 解决hash冲突

* 开放地址法：也就是说当计算好的hash值已经存入元素时，线性的向前寻找位置存储
* 链式寻址法：不再线性的向前寻找，而是在冲突的地方单线链表链式的存储，例如hashmap就是这么解决的
* 再hash法：就是利用另一个Hash函数不停的计算知道不再冲突为止
* 建立公移区：就是hash表分为两部分，基本表和公移区那么冲突的全放入公移区

##### 原理

* hashmap使用的是hash算法来进行存储的，put存入，get获取，使用数组+链表+红黑树的方式进行存储，其中数组是16，链表大于8并且容量大于64变为红黑树；如果达不到条件会扩容

#### 树

二叉树，二叉平衡树，红黑树，B树，B+树

#### 数组，list排序；string反序；

* 数组排序

```java
public class ArraySort {
    //二分查找法，查询数据
    public static void main(String[] args) {
        int [] arrays = {1,2,3,4,5,6};
        m1(arrays,0);
    }
    public static void m1 (int [] arrays,int i){
        int L = 0;
        int R = arrays.length-1;
        while (true){
            int X = (L+R)                                                                                         /2;
            if (L>R){
                System.out.println("不存在");
                return ;
            }
            if (arrays[X] == i){
                System.out.println("找到了下标为"+X+"数字是"+arrays[X]);
                return ;
            }else if(arrays[X]>i){
                R = X -1;
            }else if(arrays[X]<i){
                L = X+1;
            }
        }
    }
}
```

* list排序

  * collections.sort排序简单的list集合，若存放的是对象，则需要这个对象实现comparable接口并重写compareTo方法再使用collections.sort方法

* ```java
  public class ListSort {
      public static void main(String[] args) {
          ArrayList<Integer> integers = new ArrayList<>();
          integers.add(1);
          integers.add(5);
          integers.add(2);
          integers.add(4);
          System.out.println(integers);
          Collections.sort(integers);
          System.out.println(integers);
   //------------------------list存一个对象排序-------------------------------------------------
          User user1 = new User(1);
          User user2 = new User(3);
          User user3 = new User(2);
          User user4 = new User(5);
          User user5 = new User(4);
          ArrayList<User> integers2 = new ArrayList<>();
          integers2.add(user1);
          integers2.add(user2);
          integers2.add(user3);
          integers2.add(user4);
          integers2.add(user5);
          System.out.println(integers2);
          Collections.sort(integers2);
          System.out.println(integers2);
      }
  }
  class User implements Comparable<User>{
      private Integer integer;
  
      public Integer getInteger() {
          return integer;
      }
  
      public User(Integer integer) {
          this.integer = integer;
      }
  
      public void setInteger(Integer integer) {
          this.integer = integer;
      }
  
      @Override
      public String toString() {
          return "User{" +
                  "integer=" + integer +
                  '}';
      }
  
      @Override
      public int compareTo(User o) {
          int i =this.integer-o.integer;
          return i;
      }
  }
  ```

* String反序输入"123"返回"321"

  ```java
  String s = "abc";
          StringBuffer sB = new StringBuffer();
          sB.append(s);
          System.out.println(sB.reverse().toString());
  //扩展，如果要要判断字符串是不是回文字符串并且不让使用reverse函数的话，可以从数组中和尾遍历
  ```

### java并发编程

* **如何创建线程**：继承Thread类，实现runnable，callable接口，线程池创建，其中thread实现类runnable接口，所以当两个都有时，只会执行thread类的run方法
* **线程有哪些状态**：新建，可运行，运行，阻塞，等待，无限期等待，死亡
* **CAS**：就是比较替换，需要结合volatile来使用，内存中的真实值v，旧的预期值A，要更新的新预期值B，当A=V时可以将B替换为A，否者不更新
  * 可能会出现ABA问题解决办法时使用AtomicStampedReference类，这里面有标记可以分清A是哪个A
* **AQS**：是juc下的一个类，抽象阻塞队列，基于CLH(虚拟双向队列)来实现的，维护了volatile修饰的state变量，线程通过CAS的方式去修改state的状态，来获取锁或者加入阻塞队列等待被唤醒，唤醒呢就是前面的哪个线程使用unpark唤醒
* **如何再两个线程共享对象**：阻塞队列就可以
* **如何保证变量可见性及其原理**：volatile可以保证变量的可见性；原理是被volatile修饰的变量添加了内存屏障，也就是写指令添加的是写屏障，读指令添加的是读屏障；之后写屏障之前的所有代码都会同步到主存中，而读屏障会变量会读取主存中的值而不是自己的工作内存
* **如果线程是死循环，在宕掉jvm后是什么保证继续运行**：守护线程，
* **如何解决死循环，同步死循环和异步死循环**：如果是同步死循环就使用runnable接口，也就是之前直接调方法卸载转而使用start来启动run方法再在run中启动方法；异步死循环就是在变量上加一个volatile关键字，保证可见性

###### 线程池的使用及原理

* **线程池的参数**：7个，核心线程数，最大线程数，等待时间，时间单位，阻塞队列，拒绝策略，线程工厂
* **synchronized和lock的区别**：synchronized是一个关键字，而lock是接口；synchronized可以修饰在方法，代码块上会自动释放，lock需要手动获取并且在try final使用unlock手动释放；lock可重入，可打断，可以设置为公平锁，synchronized不行；在底层synchronized使用的是monitor重量级锁，而lock使用的是aqs实现锁

### JVM虚拟机

###### jvm有哪些模块，GC的强引用和弱引用；

* jvm有类加载器，运行时数据区(方法区，堆区，栈区，本地栈区，程序计数器)，执行引擎，本地类库，本地方法栈
* 强引用：new出来的对象就是强应用，不会被垃圾回收，即使内存不足也不会
* 软引用：当内存不足的时候会发生回收的情况，会回收掉弱引用
* 弱引用：只能活到下一次垃圾回收之前，下次一垃圾回收一定会被回收掉
* 虚引用：一个对象实际并没有虚引用，并不会对对象的生命周期有任何影响，只是在回收前会收到一个系统通知

###### oom如何解决

* 首先oom是指当98%的时间都在清理内存，但清理的内存只有不到2%的时候就是oom的时候。
* **导致的原因**有很多，例如堆内存不够，代码创建了大量的大对象并且无法回收等
* **解决方法**就是：简单来说要先判断引起oom的原因是内存泄漏还是内存溢出；dump出当前的内存转储快照来分析；如果是泄漏，那么意味着该对象已经没用了，那么需要查看他的GC Roots链来判断为什么不能呗GC回收，如果是溢出那么表示该对象确实还存货，那么需要查看堆设置参数，分析是不是能扩大堆空间，代码上也可以检查，改对象是不是存货时间过长，或者持有时间过长等
  * 可以通过指定启动参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/app/data/dump/heapdump.hpro 在发生OOM的时候自动导出Dump文件
* **内存泄漏**：是指当对象已经不再被使用了，但是无法被回收，那么就发生了内存泄漏，内存泄漏并不会导致程序崩溃，但如果内存泄漏过多就会导致oom不过两者并没有必然的联系；例如我们建立的诸多连接没有close那么就会导致内存泄漏

### Spring框架

###### restFul风格

* rest时一种风格，即在请求时有get，post，put，delete四种常用请求方式；而浏览器只认识Get和Post，所以在使用另外两种时，请求方式需要是post请求方式，并且加一个hidden标签key是"_method"value是put或者delete；并且添加HiddenHTTPMethodFilter过滤器来将put和delete的Post方法转换成对应的方法

###### proxy代理和CGLIB代理

* jdk代理基于接口，cglib基于实现类

##### 关于事务

###### spring如何管理事务

* 有三个接口：事务管理器，事务定义器，事务具体运行状态
  * 管理器：事务是否提交，是否回滚，获取事务状态
  * 定义器：获取隔离级，获取传播行为，获取超时时间，是否只读
  * 运行状态：是否包含返回点，是否已完成，是否是一个新事务

###### 事务不起作用的原因；

1. MySQL数据库不使用innoDB存储引擎
2. 方法中捕获异常--》抛出运行时异常
3. 同一个类中A方法没有声明事务，而B声明了事务，A调用了B，则B的事务不会起作用---》使用代理对象调用
4. 非public的方法上使用了注解也是无效的

###### 事务的隔离级别和传播行为

* 隔离级别：读未提交，读已提交，可重复读，序列化
* 传播行为：①如果存在事务就加入，如果不存在就新建事务②如果事务存在就加入，如果不存在就以非事务运行③如果有事务就加入，如果没有就抛异常④创建新事务，无论当前存不存在事务⑤以非事务方式运行，如果当前存在事务就挂起⑥以非事务运行如果当前存在事务就抛出异常

###### 事务Transaction原理

* springboot中不需要添加EnableTransactionManagement注解就能直接使用Transaction注解进行事务操作；因为自动装配原理，在boot启动的时候就会自动加载EnableTransactionManagement

##### 关于SpringBoot

springBoot的常用注解，boot的优点，自动装配原理，如何理解start，profile文件的作用及区分不同环境

spring的ioc原理，aop的两种代理模式；单元测试如何编写；mvc的执行流程，过滤器拦截器的区别；

###### maven中install和package的区别

* package只是简单的打包，而install会把打好的包放入maven的本地仓库中

###### Maven一二级缓存；#$区别；

* 一级缓存是默认的，二级缓存需要打开，二级缓存可以在单个mapper中<caher/>来表示开始；区别就是一级缓存在两次查询之间进行了修改操作的话会删除缓存，而二级缓存是在同一个namespace执行了commit才会失效
* $直接拼接，\#会进行预编译，防止sql注入

### Linux 命令

docker，maven，git，

* Linux查找某个关键字：grep  -rn "关键字" 文件名：-r是递归查找，-n是行号
* 查到关键字所在行后使用vi打开直接:行数；即可跳转到指定行
* docker中使用数据卷实现内外互通

cookie和session的区别和使用

### 网络协议

###### 域名和IP如何关联

###### Ajax实现同步和异步

Ajax中get请求和post请求的区别

dockerfile中的参数意义

### Mysql&Redis



###### varchar和varchar2的区别；sql优化策略；union 和union All

* varchar是标准sql类型，varchar2是Oracle特有的；varhcar中中文占两个字节，数字和英文占一个字节；varchar2若使用GBK编码则中文占两个字节，英文数字占一个，若使用UTF-8则中文占三个字节，英文数字占一个

###### 索引的使用及原理失效的场景；

* 当没有行锁的时候会使用表锁，sql语句没有匹配到索引使用表锁
* 当增删查改匹配到索引时使用行锁
* 索引的原理

